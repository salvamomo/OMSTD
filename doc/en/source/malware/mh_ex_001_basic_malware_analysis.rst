MH-EX-001: Basic malware analysis with Yara
===========================================

.. _mh-001:

In this practical example we'll create a small tool to scan the existence of malware in a system, in a very basic way, using `Yara <http://yara.readthedocs.org/en/latest/index.html>`_.

Yara is a tool whose goal is to help malware investigators to detect and classify malware.

The use of Yara can be as easy or as complex as desired. The objective of the proposed tool is just to be a PoC (Proof of Concept), functional and practical. Feel free to copy and expand the code as desired.

Problem
--------

Analyse samples of malware in batches might not result an easy task, specially if samples are of a big size or there are plenty of rules to apply.

The main difficulty is the design, implementation and documentation of the application.

Solution
--------

The proposed solution implements a system of parallel processing, distributed and automated to analyse the samples, to which new samples can be added at any moment, as they'll be enqueued to be attended as soon as possible.

The application wil generate a result in CSV format compatible with Excel.

The solution presented here follows the case studies proposed in the :ref:`desarrollo <develop_index>` block.

Implementation
--------------

Operation
+++++++++

Help in command line
********************

    Our application will run through the command line. To see every possible option, type:

    .. code-block:: bash

        python start.py --help

    The result will be:

    .. code-block:: console

        usage: start.py [-h] -p SAMPLE_PATH [-v VERBOSITY] [-o OUTPUT_FILE]
                    [--rules-path RULES_PATH]

        OMSTD Malware

        optional arguments:
          -h, --help            show this help message and exit
          -p SAMPLE_PATH, --sample-path SAMPLE_PATH
                                binary sample path
          -v VERBOSITY          enable verbose mode
          -o OUTPUT_FILE        output file name
          --rules-path RULES_PATH
                                yara rules path (default .rules/)

.. _mh-001-basic-ex:

Basic execution
***************

    The way the app works is very simple. The analyser is done using :ref:`Celery <bh-001>`, therefore you need to follow the same steps explained in the annex of the case study to run the app: :ref:`Pasos para lanzar Celery <bh-001-annex>`.

    After having launched the Celery service and its dependencies, our app is ready to receive samples to be analysed. For this, we'll run:

    .. code-block:: bash

        python start.py -p samples/sample.txt -o results

    Here we can see the output generated. A CSV with the info:

    .. code-block:: console

        HelloWorld,True,Data: 'Hello world' (flags: 19 # offset: 0),1,Rule HelloWorld was found a match in binary 'sample.txt' with tags: No tags
        HelloWorld,True,Data: 'Hello world' (flags: 19 # offset: 0),0,Rule HelloWorld was found a match in binary 'sample.txt' with tags: No tags
        Another,False,,1,Rule Another was NOT found a match in binary 'sample.txt' with tags: No tags
        SeeYou,True,Data: 'See you' (flags: 19 # offset: 12),1,Rule SeeYou was  found a match in binary 'sample.txt' with tags: No tags
        Another,False,,0,Rule Another was NOT found a match in binary 'sample.txt' with tags: No tags

Samples and example rules
*************************

    You can find examples of Celery rules and samples to test the tool immediately:

    + `Samples: <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/samples/>`_
    + `Example rules: <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/rules/>`_

    In the :ref:`Annex <mh-001-annex>` section there's a list of links with rules ready to be used.

Breakdown of pieces
+++++++++++++++++++

The parts or pieces that will compound the tool are:

+ Service that receives the new samples.
+ Result generator.
+ Tool to add new samples.

All the source code can be found `here <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001>`_.

Structure and organisation of the project follows the guidelines from :ref:`ST-001 <st-001>`.

Receiving samples
*****************

    The sample receiver service is a task of Celery, who checks for new info to analyse asynchronously as a background task.

    The analysis engine is very simple. Analysis is performed in two steps:

    + Analysis with Yara.
    + Interpretation and transformation of results.

    Both steps are defined as functions in the file `yara_task.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_.

    **Analysis with Yara**

    The function *yara_task*, converted in task with the decorator :samp:`@celery.task`, is responsible to issue the call to Yara and:

    #. Load Yara rules, with the method :samp:`yara.compile()`, with indication of the list of "\*.yara" files with the rules.
    #. Using *partials* (:ref:`LP-003 <lp-003>`), we build the callback that Yara will use every time a rule is successfully executed.
    #. Finally, the order to perform the "match" is launched, :samp:`rules.match(...)`, indicating the partial just built.

    This code shows the steps described:

    + `framework/tasks/yara_task.py -> yara_task(...) <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/yara_task.py
        :linenos:
        :lines: 87-
        :emphasize-lines: 11,14,17

    .. _mh-001-results-analysis-section:

    **Results analyser**

    The *yara_callback* function acts as the `callback <http://en.wikipedia.org/wiki/Callback_(computer_programming)>`_ that Yara will use when it finishes processing each of the rules.

    In that function, we chack the validity of input parameters, and the next actions take place:
    #. Transform input data from Yara format to the internal format, of type `Results <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/lib/data.py>`_, according to :ref:`SP-003 <st-003>`
    #. Send the information asynchronously to the task that will store the results: :samp:`celery.send_task("framework.tasks.export_results_task.export_to_csv", ...)`.

    The code below shows those steps:

    + `framework/tasks/yara_task.py -> yara_callback(...) <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/yara_task.py
        :linenos:
        :lines: 30-86
        :emphasize-lines: 44-52,55

Results generator
*****************

    Results are generated asynchronously, in the same way as reception. For that, a Celery task has been created, that waits to receive new information, with which it'll generate the desired results.

    The tool will generate results via :samp:`yara_callback(...)`. After it's done the transformation of data, it'll call a task to generate the actual results, called: :samp:`export_to_csv(...)`.

    There are several ways to call a Celery task, as can be seen in :ref:`BH-001 <bh-001>`. In this case, we're using the :samp:`my_task.send_task("...")`, option, as shown in the :ref:` previous section <mh-001-results-analysis-section>`.

    The function, converted in task, :samp:`export_to_csv(...)` does three basic things:

    #. Basic check of input parameters.
    #. Opens a file, following recommendations from :ref:`LP-005 <lp-005>`, in "append" mode, so that information is added to the end of the file, instead of overwriting it.
    #. Writes a new line in CSV format.

    This can be seen in the next lines:

    + `framework/tasks/export_results_task.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/framework/tasks/export_results_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/export_results_task.py
        :linenos:
        :lines: 29-
        :emphasize-lines: 13,16,22-28


Adding new samples
******************

    Adding new samples is equivalent to say: "send new samples to the analysis queue so that the are processed in their turn".

    For this PoC we've done something simple: **a command-line tool** (:ref:`previous sections show how to use it <mh-001-basic-ex>`).

    We've taken into consideration the following points or recommendations:

    + Used the standard **argparser** library, following Python's `official documentation <https://docs.python.org/3/library/argparse.html>`_, and following the good practices specified in :ref:`IT-001 <it-001>`.
    + Also, we have prevented accidental or badly-timed execution of the new analysis of new samples :ref:`LP-004 <lp-004>`.
    + We've decentralised one-point execution, using :ref:`ST-004 <st-004>`, and leaving the project ready for other user interfaces.
    + Used a central point to store execution parameters specified by the user, as recommended in :ref:`ST-002 <st-002>`.

    This is shown in the following lines:


    + `start.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/start.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/start.py
        :linenos:
        :lines: 25-
        :emphasize-lines: 1,3,17-20,22

    Execution takes place via the :samp:`run_all(...)` function, included in the `api.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/api.py>`_ file. Reviewing the code is useful to check that all that function does, is a call to the analysis task, with *Celery* syntax:

    + `api.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/api.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/api.py
        :linenos:
        :lines: 29-
        :emphasize-lines: 3,10


.. _mh-001-annex:

Annex
-----

You can find more information, as well as predefined Yara rules in the following URLs:

+ `https://github.com/arbor/yara <https://github.com/arbor/yara>`_
+ `https://github.com/1aN0rmus/Yara <https://github.com/1aN0rmus/Yara>`_
+ `https://github.com/0pc0deFR/YaraRules <https://github.com/0pc0deFR/YaraRules>`_
+ `https://github.com/kevthehermit/yaraMail <https://github.com/kevthehermit/yaraMail>`_
+ `https://github.com/3vangel1st/Yara <https://github.com/3vangel1st/Yara>`_
+ `https://github.com/frankenwino/yara-rules/ <https://github.com/frankenwino/yara-rules/>`_
+ `https://github.com/nxdamian/YARA-Public <https://github.com/nxdamian/YARA-Public>`_
+ `https://github.com/jackcr/yara-memory <https://github.com/jackcr/yara-memory>`_
+ `https://github.com/0pc0deFR/YaraRules <https://github.com/0pc0deFR/YaraRules>`_
+ `https://github.com/sysforensics/YaraRules <https://github.com/sysforensics/YaraRules>`_
+ `https://github.com/Neo23x0/Yara-BRG <https://github.com/Neo23x0/Yara-BRG>`_

Other interesting links:

+ `http://resources.infosecinstitute.com/yara/ <http://resources.infosecinstitute.com/yara/>`_
+ `http://resources.infosecinstitute.com/malware-analysis-clamav-yara/ <http://resources.infosecinstitute.com/malware-analysis-clamav-yara/>`_
+ `http://www.deependresearch.org/2013/02/yara-resources.html <http://www.deependresearch.org/2013/02/yara-resources.html>`_
+ `https://github.com/JoeyJoJoJrShabadu/yaragen <https://github.com/JoeyJoJoJrShabadu/yaragen>`_
+ `https://code.google.com/p/volatility/wiki/CommandReferenceMal23 <https://code.google.com/p/volatility/wiki/CommandReferenceMal23>`_