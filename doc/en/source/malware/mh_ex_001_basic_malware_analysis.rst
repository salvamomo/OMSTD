MH-EX-001: Análisis básico de malware con Yara
==============================================

.. _mh-001:

En este ejemplo práctico crearemos una pequeña herramienta que nos permita analizar, de forma muy básica, malware usando `Yara <http://yara.readthedocs.org/en/latest/index.html>`_.

Yara es una herramienta que tiene como objetivo ayudar a los investigadores de malware a clasificar y detectar malware.

El uso de Yara puede ser tan sencillo o complejo como queramos. La herramienta propuesta tiene como objetivo ser un PoC simple, funcional y práctico. Siéntase libre de copiar el código y ampliarlo como necesite.

Problema
--------

Analizar muestras de malware en batch puede puede no resultar sencillo, sobre todo si las muestras son de gran tamaño o tenemos que aplicar muchas reglas.

La principal dificultad suele ser el correcto diseño, implementación y documentación de la aplicación.

Solución
--------

La solución propuesta implementa un sistema de procesamiento paralelo, distribuido y automatizado de análisis de muestras, en el que se pueden añadir nuevas muestras en cualquier momento, quedando en cola de espera para ser atendidas.

La aplicación generará un resultado en formato CSV compatible con Excel.

Las soluciones aquí propuestas siguen los casos de estudio propuestos en el bloque de :ref:`desarrollo <develop_index>`.

Cómo
----

Funcionamiento
++++++++++++++

Ayuda en la linea de comandos
*****************************

    Nuestra aplicación se ejecuta a través de la linea de comandos. Para ver todas las opciones disponibles tan solo tenemos que escribir:

    .. code-block:: bash

        python start.py --help

    Y como resultado:

    .. code-block:: console

        usage: start.py [-h] -p SAMPLE_PATH [-v VERBOSITY] [-o OUTPUT_FILE]
                    [--rules-path RULES_PATH]

        OMSTD Malware

        optional arguments:
          -h, --help            show this help message and exit
          -p SAMPLE_PATH, --sample-path SAMPLE_PATH
                                binary sample path
          -v VERBOSITY          enable verbose mode
          -o OUTPUT_FILE        output file name
          --rules-path RULES_PATH
                                yara rules path (default .rules/)

.. _mh-001-basic-ex:

Ejecución básica
****************

    El funcionamiento es muy simple. El analizador está hecho usando :ref:`Celery <bh-001>`, por lo que hay que seguir los mismos pasos explicados en el anexo del caso de estudio :ref:`BH-001 <bh-001-annex>` para ejecutar la aplicación: :ref:`Pasos para lanzar Celery <bh-001-annex>`.

    Una vez lanzado el servicio de Celery, así como sus dependencias, nuestra aplicación ya está a la espera de recibir muestras para ser analizadas. Para esto ejecutaremos:

    .. code-block:: bash

        python start.py -p samples/sample.txt -o results

    Aquí podemos ver la salida generada: Un CSV con la información:

    .. code-block:: console

        HelloWorld,True,Data: 'Hello world' (flags: 19 # offset: 0),1,Rule HelloWorld was found a match in binary 'sample.txt' with tags: No tags
        HelloWorld,True,Data: 'Hello world' (flags: 19 # offset: 0),0,Rule HelloWorld was found a match in binary 'sample.txt' with tags: No tags
        Another,False,,1,Rule Another was NOT found a match in binary 'sample.txt' with tags: No tags
        SeeYou,True,Data: 'See you' (flags: 19 # offset: 12),1,Rule SeeYou was  found a match in binary 'sample.txt' with tags: No tags
        Another,False,,0,Rule Another was NOT found a match in binary 'sample.txt' with tags: No tags

Muestras y reglas de ejemplo
****************************

    Puede encontrar muestras y reglas Celery de ejemplo, para poder probar la herramienta inmediatamente:

    + `Muestras de ejemplo <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/samples/>`_
    + `Reglas de ejemplo <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/rules/>`_

    En la sección :ref:`Anexo <mh-001-annex>` puede encontrar un listado de enlaces con reglas listas para ser utilizadas.

Desglose de las piezas
++++++++++++++++++++++

Las piezas que compondrán la herramienta son las siguientes:

+ Servicio que recibe nuevas muestras.
+ Generador de resultados.
+ Medio para añadir nuevas muestras

Todo el código fuente lo puedes descargar y probar `aquí <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001>`_.

La estructura y organización del proyecto sigue las directrices de :ref:`ST-001 <st-001>`.

Recepción de muestras
*********************

    El servicio de recepción de muestras es un tarea de Celery, a la espera de recibir nueva información para analizar de forma asíncrona y en background.

    El motor de análisis es muy sencillo. El análisis se hace en dos partes:

    + El análisis con Yara.
    + La interpretación y transformación de resultados.

    Ambas partes están definidas como dos funciones en el fichero `yara_task.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_.

    **Analizador con Yara**

    La función *yara_task*, convertida en tarea con el decorador :samp:`@celery.task`, es la encargada de hacer la llamada a Yara y:

    #. Cargar las reglas Yara, con el método :samp:`yara.compile()`, indicándole el listado de ficheros "\*.yara" con las reglas.
    #. Usando *partials* (:ref:`LP-003 <lp-003>`) construimos la llamada al callback. Dicho callback será llamado por la librería de Yara, cada vez que ésta ejecute con éxito una regla.
    #. Finalmente se lanza la orden para hacer el "match", :samp:`rules.match(...)`, indicándole el partial anteriormente construido.

    En el siguiente código se puede ver estos puntos:

    + `framework/tasks/yara_task.py -> yara_task(...) <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/yara_task.py
        :linenos:
        :lines: 87-
        :emphasize-lines: 11,14,17

    .. _mh-001-results-analysis-section:

    **Analizador de resultados**

    La función *yara_callback* actúa como `callback <http://en.wikipedia.org/wiki/Callback_(computer_programming)>`_ que Yara llamará cuando termine de procesar cada una de las reglas.

    En ella, y tras comprobarse la validez de los parámetros de entrada, se llevan a cabo las siguientes acciones:
    #. Transformar los datos de entrada del formato Yara al formato interno, del tipo `Results <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/lib/data.py>`_, según :ref:`SP-003 <st-003>`
    #. Enviar la información, de forma asíncrona, a la tarea que se encarga de almacenar los resultados: :samp:`celery.send_task("framework.tasks.export_results_task.export_to_csv", ...)`.

    En el siguiente código se puede ver estos puntos:

    + `framework/tasks/yara_task.py -> yara_callback(...) <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/framework/tasks/yara_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/yara_task.py
        :linenos:
        :lines: 30-86
        :emphasize-lines: 44-52,55

Generador de resultados
***********************

    Los resultados serán generados de forma asíncrona, al igual que la recepción de éstos. Para ello, se ha creado una tarea de Celery, a la espera de recibir nueva información, con la que generar los resultados deseados.

    La herramienta genera los resultados a través de la función :samp:`yara_callback(...)`. Ésta, una vez hecha la transformación, hace una llamada la a la tarea generadora de resultados, llamada: :samp:`export_to_csv(...)`.

    Hay varias formas de llamar a una tarea de Celery, como se puede estudiar en :ref:`BH-001 <bh-001>`. En este caso nos hemos decantado por la opción :samp:`my_task.send_task("...")`, como se ha visto en la :ref:` sección anterior <mh-001-results-analysis-section>`.

    La función, convertida en tarea, :samp:`export_to_csv(...)` hace 3 cosas muy sencillas:

    #. Una comprobación mínima de los parámetros de entrada.
    #. Abre un fichero, siguiendo las recomendaciones de :ref:`LP-005 <lp-005>`, en modo "append" o para añadir información al final de éste.
    #. Escribe una nueva linea en el fichero en formato csv

    Tal y como podemos ver en la lineas señaladas:

    + `framework/tasks/export_results_task.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/framework/tasks/export_results_task.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/framework/tasks/export_results_task.py
        :linenos:
        :lines: 29-
        :emphasize-lines: 13,16,22-28


Añadir nuevas muestras
**********************

    Añadir nuevas muestras, es equivalente a decir: enviar nuevas muestras a la cola de análisis, para que sean procesadas cuando toque su turno.

    Para este PoC se ha optado por algo sencillo: **un linea de comandos** (:ref:`en secciones anteriores se muestra cómo ejecutarse <mh-001-basic-ex>`).

    Hemos tenido en cuenta las siguientes medidas o recomendaciones:

    + Hemos usado la librería standard **argparser**, siguiendo la sintaxis de la `documentación oficial <https://docs.python.org/3/library/argparse.html>`_, y teniendo en cuenta las buenas prácticas especificadas en :ref:`IT-001 <it-001>`.
    + Además, hemos prevenido la ejecución accidental o a destiempo aplicando :ref:`LP-004 <lp-004>`.
    + Hemos centralizado la ejecución en un punto, usando :ref:`ST-004 <st-004>`, dejando preparado el proyecto para otras interfaces de usuario.
    + Hemos usado un punto central para almacenar los parámetros de ejecución del usuario, como se recomienda en :ref:`ST-002 <st-002>`.

    Tal y como podemos ver en la lineas señaladas:


    + `start.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/start.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/start.py
        :linenos:
        :lines: 25-
        :emphasize-lines: 1,3,17-20,22

    La ejecución tiene lugar a través de la función :samp:`run_all(...)`, incluido en el fichero `api.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/api.py>`_. Si observamos el código, podemos comprobar que lo que hace dicha función es una llamada a la tarea de análisis, con sintaxis *Celery*:

    + `api.py <https://github.com/cr0hn/OMSTD/blob/master/examples/malware/mh-001/api.py>`_:

    .. literalinclude:: ../../../../examples/malware/mh-001/api.py
        :linenos:
        :lines: 29-
        :emphasize-lines: 3,10


.. _mh-001-annex:

Anexo
-----

Se puede encontrar más información, así como reglas Yara predefinidas en las siguientes URL:

+ `https://github.com/arbor/yara <https://github.com/arbor/yara>`_
+ `https://github.com/1aN0rmus/Yara <https://github.com/1aN0rmus/Yara>`_
+ `https://github.com/0pc0deFR/YaraRules <https://github.com/0pc0deFR/YaraRules>`_
+ `https://github.com/kevthehermit/yaraMail <https://github.com/kevthehermit/yaraMail>`_
+ `https://github.com/3vangel1st/Yara <https://github.com/3vangel1st/Yara>`_
+ `https://github.com/frankenwino/yara-rules/ <https://github.com/frankenwino/yara-rules/>`_
+ `https://github.com/nxdamian/YARA-Public <https://github.com/nxdamian/YARA-Public>`_
+ `https://github.com/jackcr/yara-memory <https://github.com/jackcr/yara-memory>`_
+ `https://github.com/0pc0deFR/YaraRules <https://github.com/0pc0deFR/YaraRules>`_
+ `https://github.com/sysforensics/YaraRules <https://github.com/sysforensics/YaraRules>`_
+ `https://github.com/Neo23x0/Yara-BRG <https://github.com/Neo23x0/Yara-BRG>`_

Otros enlaces interesantes:

+ `http://resources.infosecinstitute.com/yara/ <http://resources.infosecinstitute.com/yara/>`_
+ `http://resources.infosecinstitute.com/malware-analysis-clamav-yara/ <http://resources.infosecinstitute.com/malware-analysis-clamav-yara/>`_
+ `http://www.deependresearch.org/2013/02/yara-resources.html <http://www.deependresearch.org/2013/02/yara-resources.html>`_
+ `https://github.com/JoeyJoJoJrShabadu/yaragen <https://github.com/JoeyJoJoJrShabadu/yaragen>`_
+ `https://code.google.com/p/volatility/wiki/CommandReferenceMal23 <https://code.google.com/p/volatility/wiki/CommandReferenceMal23>`_